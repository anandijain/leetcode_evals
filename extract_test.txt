Approach:\nNot much different from the Two Sum.\nSort array so as to find triplets easily.\nRun a loop from 0 to n-3.\nWe deal with only distinct elements.\nFor each i, consider all distinct pairs with greater index, say i+1 to n-1.\nIf the sum of i-th element, j-th element and k-th element is zero, just add it to answer. Now we need to avoid duplicate triplets which if we do naively will result in TLE as there could be n^3 triplets. Thus, we skip if the current element is same as the previous element.\n\nAlgorithm:\nInitialise an empty list to store the triplets which sum to zero.\nIf len(nums)<3, return []\nNow the main part is to avoid duplicates so as to not linerarly search the vector which will result in TLE for large inputs\nSort the input list\nRun a loop over the input list, i.e. from i=0 to n-3\nThen run a pointer from i+1 to n-1, and define left pointer, l=i+1 and right pointer, r=n-1Â¶\nThen for each pair of indices (l, r), check if the sum of elements at those indices, along with element at index i, the sum is equal to 0\nIf sum is less than 0, increment left pointer l by 1\nIf sum is greater than 0, decrement right pointer r by 1\nIf sum is equal to 0, we have found a triplet (i, l, r), so we append it to our answer list i.e the list of triplets\nAt this point, we need to skip duplicate values for i, l or r so that we don't repeat triplet, which sum to zero. Let's handle the cases separately:\nWe do not need to check for cases when the value at index i is the same as the value at index i-1 since that would have been previously visited and stored into our answer list of triplets. Thus, in such cases, we skip the current iteration\nIf the value at index l or index r is same as the previous one i.e. nums[l]==nums[l-1] or nums[r]==nums[r+1], we also need to skip that iteration as these would result in repeating triplet\nRight before the loop of pointer, we check that if nums[i]>0, it is impossible to find the triplet that sums to zero.\nOtherwise we continue the loop for finding the triplet\n\nReturn the final answer list of triplets\n\nTime Complexity:\nApproach requires sorting the list O(nlogn), but the main execution comes from finding the triplets. We need to loop over the input list three times which results in cubic time complexity. However, as we discussed before, if we sort the input, we can eliminate one of the loops. Thus, the time complexity is O(n^2).\nSpace Complexity:\nO(1) as we only store a few variables at each step. No extra space is used. Thus, space complexity is constant.\n\nLet's see the code.  \n``` rust  \nimpl Solution {\n    pub fn three_sum(mut nums: Vec<i32>) -> Vec<Vec<i32>> {\n        //if length of array is less than 3\n        let mut ans=vec![];\n        let n=nums.len();\n        if n<3 {\n            return ans;\n        }\n        //sort the array\n        nums.sort();\n        for i in 0..n-2 {\n            //if nums[i] is greater than 0, break the loop since we cannot find a triplet in a sorted array which sums to 0\n            if nums[i]>0 {\n                break;\n            }\n            //skip the same value of i element, in case of nums[i]==nums[i-1]\n            if i>0 && nums[i]==nums[i-1] {\n                continue;\n            }\n            //taking pointers from i+1 to n-1\n            let mut left=i+1;\n            let mut right=n-1;\n            while left<right {\n                let sum=nums[i]+nums[left]+nums[right];\n                //if sum==0, we have found the triplets\n                if sum==0 {\n                    ans.push(vec![nums[i], nums[left], nums[right]]);\n                                        //skip the same value of left and right element\n                                        while left<right && nums[left]==nums[left+1] {\n                        left+=1;\n                    }\n                                        while left<right && nums[right]==nums[right-1] {\n                        right-=1;\n                    }\n                    left+=1;\n                    right-=1;\n                }\n                //sum<0 increment left pointer\n                else if sum<0 {\n                    left+=1;\n                }\n                //sum>0 decrement right pointer\n                else {\n                    right-=1;\n                }\n            }\n        }\n        return ans;\n    }\n}\n```